# Build and push the script image to ECR, which will be used by Lambda functions.
name: Build services and push to ECR
on:
  push:
    branches:
      - main
  workflow_dispatch:
jobs:
  build-and-push-to-ecr:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history so turbo can compare with origin/main if needed

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.20.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "24"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Determine affected services
        id: affected
        run: |
          echo "ğŸ” Determining affected services..."
          echo ""

          # Helper function to map package names to their paths
          map_package_to_path() {
            local pkg_name=$1
            # Find the actual path for this package name in apps directory
            local pkg_path=$(find apps -type f -name "package.json" -not -path "*/node_modules/*" \
              -exec grep -l "\"name\": \"$pkg_name\"" {} \; | head -1 | xargs dirname 2>/dev/null)
            if [ -n "$pkg_path" ]; then
              echo "$pkg_path"
            fi
          }

          # Get affected packages using turbo
          # Compare with the previous commit or main branch
          if [ "${{ github.event_name }}" = "push" ]; then
            BASE_REF="HEAD^1"
            echo "ğŸ“ Trigger: Push to main branch"
          else
            BASE_REF="origin/main"
            echo "ğŸ“ Trigger: Manual workflow dispatch"
          fi

          # Run turbo to get affected packages based on changes
          # This considers the dependency graph, so changes to shared packages will affect dependents
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # For manual triggers, build all apps packages (useful for manual deployments)
            TURBO_FILTER="./apps/**"
            echo "ğŸ¯ Strategy: Building all services (manual trigger)"
          else
            # For push events, get packages affected by changes since base ref
            # Syntax: {scope}[gitRange] where scope matches packages and gitRange specifies the comparison
            TURBO_FILTER="{./apps/**}[${BASE_REF}]"
            echo "ğŸ¯ Strategy: Building affected services since ${BASE_REF}"
          fi

          echo ""

          # Get affected package names from turbo
          # Note: grep returns exit code 1 when no matches found, use || true to prevent script failure
          AFFECTED_PKG_NAMES=$(pnpm turbo run build --filter="${TURBO_FILTER}" --dry=json 2>/dev/null | \
            jq -r '.packages[]' | grep -v '^//$' || true)

          # Map package names to their actual paths
          AFFECTED_PACKAGES=$(echo "$AFFECTED_PKG_NAMES" | \
            while read -r pkg_name; do
              [ -z "$pkg_name" ] && continue
              pkg_path=$(map_package_to_path "$pkg_name")
              if [ -n "$pkg_path" ]; then
                echo "$pkg_path"
              fi
            done | \
            jq -R -s -c 'split("\n")[:-1]')

          echo "affected_packages=${AFFECTED_PACKAGES}" >> $GITHUB_OUTPUT

          # Display affected packages
          PACKAGE_COUNT=$(echo "$AFFECTED_PACKAGES" | jq 'length')
          if [ "$PACKAGE_COUNT" -eq 0 ]; then
            echo "â„¹ï¸ No services affected"
          else
            echo "ğŸ“¦ Found $PACKAGE_COUNT affected service(s):"
            echo "$AFFECTED_PACKAGES" | jq -r '.[]' | while read -r pkg; do
              echo "   â€¢ ${pkg#apps/}"
            done
          fi
          echo ""

      - name: Build and push Docker images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          AFFECTED_PACKAGES: ${{ steps.affected.outputs.affected_packages }}
        run: |
          echo "## ğŸš€ Build and Push to ECR Summary" > summary.txt
          echo "" >> summary.txt
          echo "**Commit:** \`${{ github.sha }}\`" >> summary.txt
          echo "**Trigger:** ${{ github.event_name }}" >> summary.txt
          echo "**Branch:** \`${{ github.ref_name }}\`" >> summary.txt
          echo "" >> summary.txt

          # Check if there are any affected packages
          if [ "$AFFECTED_PACKAGES" = "[]" ] || [ -z "$AFFECTED_PACKAGES" ]; then
            echo "### â„¹ï¸ No Services to Build" >> summary.txt
            echo "" >> summary.txt
            echo "No services were affected by this change. No images built or pushed." >> summary.txt
            cat summary.txt >> $GITHUB_STEP_SUMMARY
            echo "â„¹ï¸ No services to build - skipping"
            exit 0
          fi

          TOTAL_COUNT=$(echo "$AFFECTED_PACKAGES" | jq 'length')
          echo "### ğŸ“¦ Services to Build: $TOTAL_COUNT" >> summary.txt
          echo "" >> summary.txt

          BUILD_FAILED=0
          SUCCESS_SERVICES=()
          FAILED_SERVICES=()
          MISSING_DOCKERFILE=()

          echo "ğŸ³ Building and pushing Docker images to ECR..."
          echo ""

          # Parse affected packages and build Docker images
          while IFS= read -r package; do
            # Skip empty lines
            [ -z "$package" ] && continue

            # Determine paths and repository names
            DOCKERFILE_PATH="${package}/Dockerfile"
            # Convert package path to ECR repository name
            # e.g., apps/api/account-service -> cca/api/account-service
            # e.g., apps/ui -> cca/ui
            ECR_REPO="cca/${package#apps/}"
            SERVICE_NAME="${package#apps/}"

            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“¦ Service: $SERVICE_NAME"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

            # Check if Dockerfile exists
            if [ ! -f "$DOCKERFILE_PATH" ]; then
              echo "âŒ Dockerfile not found at $DOCKERFILE_PATH"
              MISSING_DOCKERFILE+=("$SERVICE_NAME")
              BUILD_FAILED=1
              echo ""
              continue
            fi

            echo "ï¿½ Dockerfile: $DOCKERFILE_PATH"
            echo "ğŸ·ï¸  ECR Repository: $ECR_REPO"
            echo ""

            # Build and push the image using standard docker commands
            set +e

            # Build the image
            echo "ğŸ”¨ Building Docker image..."
            docker buildx build \
              --platform linux/arm64 \
              --file "$DOCKERFILE_PATH" \
              --tag "$ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG" \
              --tag "$ECR_REGISTRY/$ECR_REPO:latest" \
              --push \
              .
            BUILD_EXIT_CODE=$?

            # Check if build and push succeeded
            if [ $BUILD_EXIT_CODE -eq 0 ]; then
              echo ""
              echo "âœ… Successfully built and pushed!"
              echo "   Image: $ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG (linux/arm64)"
              SUCCESS_SERVICES+=("$SERVICE_NAME|$ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG")
            else
              echo ""
              echo "âŒ Build or push failed!"
              FAILED_SERVICES+=("$SERVICE_NAME")
              BUILD_FAILED=1
            fi

            echo ""
          done < <(echo "$AFFECTED_PACKAGES" | jq -r '.[]')

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""

          # Build summary sections
          if [ ${#SUCCESS_SERVICES[@]} -gt 0 ]; then
            echo "#### âœ… Successfully Built and Pushed (${#SUCCESS_SERVICES[@]})" >> summary.txt
            echo "" >> summary.txt
            for service_info in "${SUCCESS_SERVICES[@]}"; do
              IFS='|' read -r service_name image_uri <<< "$service_info"
              echo "- **\`$service_name\`**" >> summary.txt
              echo "  - Image: \`$image_uri\`" >> summary.txt
            done
            echo "" >> summary.txt
          fi

          if [ ${#MISSING_DOCKERFILE[@]} -gt 0 ]; then
            echo "#### âŒ Missing Dockerfile (${#MISSING_DOCKERFILE[@]})" >> summary.txt
            echo "" >> summary.txt
            for service in "${MISSING_DOCKERFILE[@]}"; do
              echo "- âŒ \`$service\` - No Dockerfile found" >> summary.txt
            done
            echo "" >> summary.txt
          fi

          if [ ${#FAILED_SERVICES[@]} -gt 0 ]; then
            echo "#### âŒ Build/Push Failed (${#FAILED_SERVICES[@]})" >> summary.txt
            echo "" >> summary.txt
            for service in "${FAILED_SERVICES[@]}"; do
              echo "- âŒ \`$service\` - Check logs for details" >> summary.txt
            done
            echo "" >> summary.txt
          fi

          # Overall status
          echo "---" >> summary.txt
          echo "" >> summary.txt

          if [ $BUILD_FAILED -eq 0 ]; then
            echo "### âœ… All Services Deployed Successfully" >> summary.txt
            echo "" >> summary.txt
            echo "All affected services were built and pushed to ECR successfully." >> summary.txt
            echo "âœ… All services deployed successfully!"
          else
            echo "### âŒ Deployment Failed" >> summary.txt
            echo "" >> summary.txt
            if [ ${#MISSING_DOCKERFILE[@]} -gt 0 ]; then
              echo "- ${#MISSING_DOCKERFILE[@]} service(s) missing Dockerfile" >> summary.txt
            fi
            if [ ${#FAILED_SERVICES[@]} -gt 0 ]; then
              echo "- ${#FAILED_SERVICES[@]} service(s) failed to build or push" >> summary.txt
            fi
            echo "âŒ Some services failed to deploy"
          fi

          # Add summary to GitHub Actions summary
          cat summary.txt >> $GITHUB_STEP_SUMMARY

          # Exit with error if any build failed
          if [ $BUILD_FAILED -eq 1 ]; then
            echo ""
            echo "::error::One or more services failed to build or push to ECR"
            exit 1
          fi
