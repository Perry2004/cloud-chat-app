# Build and push the script image to ECR, which will be used by Lambda functions.
name: Build services and push to ECR
on:
  push:
    branches:
      - main
  workflow_dispatch:
jobs:
  build-and-push-to-ecr:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history so turbo can compare with origin/main if needed

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.20.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Determine affected services
        id: affected
        run: |
          # Helper function to map package names to their paths
          map_package_to_path() {
            local pkg_name=$1
            # Find the actual path for this package name in apps directory
            local pkg_path=$(find apps -type f -name "package.json" -not -path "*/node_modules/*" \
              -exec grep -l "\"name\": \"$pkg_name\"" {} \; | head -1 | xargs dirname 2>/dev/null)
            if [ -n "$pkg_path" ]; then
              echo "$pkg_path"
            fi
          }

          # Get affected packages using turbo
          # Compare with the previous commit or main branch
          if [ "${{ github.event_name }}" = "push" ]; then
            BASE_REF="HEAD^1"
          else
            BASE_REF="origin/main"
          fi

          # Run turbo to get affected packages based on changes
          # This considers the dependency graph, so changes to shared packages will affect dependents
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # For manual triggers, build all apps packages (useful for manual deployments)
            TURBO_FILTER="./apps/**"
            echo "Manual trigger: building all packages in apps"
          else
            # For push events, get packages affected by changes since base ref
            # Syntax: {scope}[gitRange] where scope matches packages and gitRange specifies the comparison
            TURBO_FILTER="{./apps/**}[${BASE_REF}]"
            echo "Automatic trigger: building packages affected since ${BASE_REF}"
          fi

          echo "Using turbo filter: ${TURBO_FILTER}"

          # Get affected package names from turbo
          # Note: grep returns exit code 1 when no matches found, use || true to prevent script failure
          AFFECTED_PKG_NAMES=$(pnpm turbo run build --filter="${TURBO_FILTER}" --dry=json 2>/dev/null | \
            jq -r '.packages[]' | grep -v '^//$' || true)

          # Map package names to their actual paths
          AFFECTED_PACKAGES=$(echo "$AFFECTED_PKG_NAMES" | \
            while read -r pkg_name; do
              [ -z "$pkg_name" ] && continue
              pkg_path=$(map_package_to_path "$pkg_name")
              if [ -n "$pkg_path" ]; then
                echo "$pkg_path"
              fi
            done | \
            jq -R -s -c 'split("\n")[:-1]')

          echo "affected_packages=${AFFECTED_PACKAGES}" >> $GITHUB_OUTPUT
          echo "Affected packages: ${AFFECTED_PACKAGES}"

      - name: Build and push Docker images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          AFFECTED_PACKAGES: ${{ steps.affected.outputs.affected_packages }}
        run: |
          echo "## Build Summary" > summary.txt
          echo "" >> summary.txt
          echo "**Commit:** ${{ github.sha }}" >> summary.txt
          echo "" >> summary.txt
          echo "### Images Built:" >> summary.txt
          echo "" >> summary.txt

          # Check if there are any affected packages
          if [ "$AFFECTED_PACKAGES" = "[]" ] || [ -z "$AFFECTED_PACKAGES" ]; then
            echo "â„¹ï¸ No affected packages with Dockerfiles found"
            echo "- â„¹ï¸ No services affected by this change" >> summary.txt
            cat summary.txt >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          BUILD_FAILED=0

          # Parse affected packages and build Docker images
          while IFS= read -r package; do
            # Skip empty lines
            [ -z "$package" ] && continue

            # Determine paths and repository names
            DOCKERFILE_PATH="${package}/Dockerfile"
            # Convert package path to ECR repository name
            # e.g., apps/api/account-service -> cca/api/account-service
            # e.g., apps/ui -> cca/ui
            ECR_REPO="cca/${package#apps/}"

            echo "ðŸ”¨ Building $package..."
            echo "   Dockerfile: $DOCKERFILE_PATH"
            echo "   ECR Repository: $ECR_REPO"

            # Build and push the image using standard docker commands
            set +e

            # Build the image
            docker build \
              --file "$DOCKERFILE_PATH" \
              --tag "$ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG" \
              --tag "$ECR_REGISTRY/$ECR_REPO:latest" \
              .
            BUILD_EXIT_CODE=$?

            # If build succeeded, push to ECR
            if [ $BUILD_EXIT_CODE -eq 0 ]; then
              echo "ðŸ“¤ Pushing image to ECR..."
              docker push "$ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG"
              BUILD_EXIT_CODE=$?

              if [ $BUILD_EXIT_CODE -eq 0 ]; then
                docker push "$ECR_REGISTRY/$ECR_REPO:latest"
                BUILD_EXIT_CODE=$?
              fi
            fi

            set -e

            if [ $BUILD_EXIT_CODE -eq 0 ]; then
              echo "âœ… Successfully built and pushed $package"
              echo "   Image: $ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG"
              echo "- âœ… \`$ECR_REPO:$IMAGE_TAG\`" >> summary.txt
            else
              echo "âŒ Failed to build $package"
              echo "- âŒ \`$ECR_REPO\` (build failed)" >> summary.txt
              BUILD_FAILED=1
            fi

            echo ""
          done < <(echo "$AFFECTED_PACKAGES" | jq -r '.[]')

          # Add summary to GitHub Actions summary
          cat summary.txt >> $GITHUB_STEP_SUMMARY

          # Exit with error if any build failed
          if [ $BUILD_FAILED -eq 1 ]; then
            echo "::error::One or more Docker builds failed"
            exit 1
          fi
