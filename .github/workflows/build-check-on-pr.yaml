# Build check for affected services on pull requests
name: Build Check on PR
on:
  pull_request:
    branches:
      - main
jobs:
  build-check:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history so turbo can compare with base branch

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.20.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "24"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Determine affected services
        id: affected
        run: |
          # Helper function to map package names to their paths
          map_package_to_path() {
            local pkg_name=$1
            # Find the actual path for this package name in apps directory
            local pkg_path=$(find apps -type f -name "package.json" -not -path "*/node_modules/*" \
              -exec grep -l "\"name\": \"$pkg_name\"" {} \; | head -1 | xargs dirname 2>/dev/null)
            if [ -n "$pkg_path" ]; then
              echo "$pkg_path"
            fi
          }

          # Get affected packages using turbo
          # Compare with the base branch (target of PR)
          BASE_REF="origin/${{ github.base_ref }}"

          # Run turbo to get affected packages based on changes
          # This considers the dependency graph, so changes to shared packages will affect dependents
          TURBO_FILTER="{./apps/**}[${BASE_REF}]"
          echo "Building packages affected since ${BASE_REF}"
          echo "Using turbo filter: ${TURBO_FILTER}"

          # Get affected package names from turbo
          # Note: grep returns exit code 1 when no matches found, use || true to prevent script failure
          AFFECTED_PKG_NAMES=$(pnpm turbo run build --filter="${TURBO_FILTER}" --dry=json 2>/dev/null | \
            jq -r '.packages[]' | grep -v '^//$' || true)

          # Map package names to their actual paths
          AFFECTED_PACKAGES=$(echo "$AFFECTED_PKG_NAMES" | \
            while read -r pkg_name; do
              [ -z "$pkg_name" ] && continue
              pkg_path=$(map_package_to_path "$pkg_name")
              if [ -n "$pkg_path" ]; then
                echo "$pkg_path"
              fi
            done | \
            jq -R -s -c 'split("\n")[:-1]')

          echo "affected_packages=${AFFECTED_PACKAGES}" >> $GITHUB_OUTPUT
          echo "Affected packages: ${AFFECTED_PACKAGES}"

      - name: Build affected services
        id: build
        env:
          AFFECTED_PACKAGES: ${{ steps.affected.outputs.affected_packages }}
        run: |
          # Check if there are any affected packages
          if [ "$AFFECTED_PACKAGES" = "[]" ] || [ -z "$AFFECTED_PACKAGES" ]; then
            echo "‚ÑπÔ∏è No services affected by this change"
            echo "build_status=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "üî® Building affected services..."
          echo ""

          # Build affected packages using turbo
          BASE_REF="origin/${{ github.base_ref }}"
          TURBO_FILTER="{./apps/**}[${BASE_REF}]"

          # Capture build output and status
          set +e
          BUILD_OUTPUT=$(pnpm turbo run build --filter="${TURBO_FILTER}" 2>&1)
          BUILD_EXIT_CODE=$?
          set -e

          echo "$BUILD_OUTPUT"
          echo ""

          if [ $BUILD_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ All services built successfully"
            echo "build_status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Build failed for one or more services"
            echo "build_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Check Dockerfiles exist
        if: always()
        env:
          AFFECTED_PACKAGES: ${{ steps.affected.outputs.affected_packages }}
          BUILD_STATUS: ${{ steps.build.outputs.build_status }}
        run: |
          echo "## üìã Build Check Summary" > summary.txt
          echo "" >> summary.txt
          echo "**PR:** #${{ github.event.pull_request.number }}" >> summary.txt
          echo "**Branch:** \`${{ github.head_ref }}\`" >> summary.txt
          echo "" >> summary.txt

          # Check if there are any affected packages
          if [ "$AFFECTED_PACKAGES" = "[]" ] || [ -z "$AFFECTED_PACKAGES" ]; then
            echo "### ‚ÑπÔ∏è No Services Affected" >> summary.txt
            echo "" >> summary.txt
            echo "No services were affected by changes in this PR." >> summary.txt
            cat summary.txt >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Count services
          TOTAL_COUNT=$(echo "$AFFECTED_PACKAGES" | jq 'length')
          echo "### üì¶ Affected Services: $TOTAL_COUNT" >> summary.txt
          echo "" >> summary.txt

          # Build status section
          echo "#### üî® Build Status" >> summary.txt
          echo "" >> summary.txt
          if [ "$BUILD_STATUS" = "success" ]; then
            echo "‚úÖ **All services built successfully**" >> summary.txt
          elif [ "$BUILD_STATUS" = "failed" ]; then
            echo "‚ùå **Build failed** - Check logs above for details" >> summary.txt
          else
            echo "‚è≠Ô∏è **Build skipped**" >> summary.txt
          fi
          echo "" >> summary.txt

          # Dockerfile check section
          echo "#### üê≥ Dockerfile Check" >> summary.txt
          echo "" >> summary.txt

          DOCKERFILE_FAILED=0
          SUCCESS_SERVICES=()
          FAILED_SERVICES=()

          # Parse affected packages and check for Dockerfiles
          while IFS= read -r package; do
            # Skip empty lines
            [ -z "$package" ] && continue

            DOCKERFILE_PATH="${package}/Dockerfile"
            SERVICE_NAME="${package#apps/}"

            # Check if Dockerfile exists
            if [ ! -f "$DOCKERFILE_PATH" ]; then
              echo "‚ùå Missing Dockerfile: $package"
              FAILED_SERVICES+=("$SERVICE_NAME")
              DOCKERFILE_FAILED=1
            else
              echo "‚úÖ Found Dockerfile: $package"
              SUCCESS_SERVICES+=("$SERVICE_NAME")
            fi
          done < <(echo "$AFFECTED_PACKAGES" | jq -r '.[]')

          # Summary of Dockerfile checks
          if [ ${#SUCCESS_SERVICES[@]} -gt 0 ]; then
            echo "**‚úÖ Services with Dockerfile (${#SUCCESS_SERVICES[@]}):**" >> summary.txt
            for service in "${SUCCESS_SERVICES[@]}"; do
              echo "- ‚úÖ \`$service\`" >> summary.txt
            done
            echo "" >> summary.txt
          fi

          if [ ${#FAILED_SERVICES[@]} -gt 0 ]; then
            echo "**‚ùå Services missing Dockerfile (${#FAILED_SERVICES[@]}):**" >> summary.txt
            for service in "${FAILED_SERVICES[@]}"; do
              echo "- ‚ùå \`$service\`" >> summary.txt
            done
            echo "" >> summary.txt
          fi

          # Overall status
          echo "---" >> summary.txt
          echo "" >> summary.txt

          if [ "$BUILD_STATUS" = "success" ] && [ $DOCKERFILE_FAILED -eq 0 ]; then
            echo "### ‚úÖ All Checks Passed" >> summary.txt
            echo "" >> summary.txt
            echo "All affected services built successfully and have Dockerfiles ready for deployment." >> summary.txt
          else
            echo "### ‚ùå Checks Failed" >> summary.txt
            echo "" >> summary.txt
            if [ "$BUILD_STATUS" = "failed" ]; then
              echo "- Build failed for one or more services" >> summary.txt
            fi
            if [ $DOCKERFILE_FAILED -eq 1 ]; then
              echo "- One or more services are missing Dockerfiles" >> summary.txt
            fi
          fi

          # Add summary to GitHub Actions summary
          cat summary.txt >> $GITHUB_STEP_SUMMARY

          # Exit with error if any check failed
          if [ $DOCKERFILE_FAILED -eq 1 ]; then
            echo ""
            echo "::error::One or more services are missing Dockerfiles"
            exit 1
          fi

          # Also fail if build failed
          if [ "$BUILD_STATUS" = "failed" ]; then
            exit 1
          fi
